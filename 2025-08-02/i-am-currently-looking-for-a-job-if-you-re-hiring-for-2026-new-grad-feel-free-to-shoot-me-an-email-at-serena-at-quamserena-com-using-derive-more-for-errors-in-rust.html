<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"><link rel="stylesheet" href="/main.css"><title>I am currently looking for a job! If you're hiring for 2026 new grad, feel free to shoot me an email at serena (at) quamserena.com. Using derive_more for errors in Rust
</title><link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="shortcut icon" href="/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><meta name="apple-mobile-web-app-title" content="quam serena"><link rel="manifest" href="/site.webmanifest"></head><body><header><h1><a style="all: unset; cursor: pointer" href="/">quam serena</a></h1></header><main><article><p><em>I am currently looking for a job! If you're hiring for 2026 new grad, feel free to shoot me an email at serena (at) quamserena.com.</em></p>
<h1>Using <code>derive_more</code> for errors in Rust</h1>
<p>Errors can be very annoying in Rust. This is not necessarily a bad thing, though, because unlike other languages, Rust forces you to actually think about errors at compile time rather than be surprised at run time. Let's look at an example function, which might return an error:</p>
<pre style="background-color:#1e1e2e;"><code class="language-rust"><span style="color:#fab387;">#</span><span style="color:#f9e2af;">[derive(Debug)]
</span><span style="color:#cba6f7;">struct </span><span style="color:#f9e2af;">FooError</span><span style="color:#9399b2;">;
</span><span style="color:#cdd6f4;">
</span><span style="color:#cba6f7;">fn </span><span style="color:#89b4fa;">foo</span><span style="color:#9399b2;">() -&gt; </span><span style="color:#fab387;">Result</span><span style="color:#94e2d5;">&lt;</span><span style="color:#9399b2;">()</span><span style="color:#fab387;">, FooError</span><span style="color:#94e2d5;">&gt; </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    </span><span style="color:#94e2d5;">...
</span><span style="color:#9399b2;">}
</span></code></pre>
<p>We'll say that <code>FooError</code> contains some error information data which is unique to <code>foo()</code>. And now let's say the same for another function, <code>bar()</code>:</p>
<pre style="background-color:#1e1e2e;"><code class="language-rust"><span style="color:#fab387;">#</span><span style="color:#f9e2af;">[derive(Debug)]
</span><span style="color:#cba6f7;">struct </span><span style="color:#f9e2af;">BarError</span><span style="color:#9399b2;">;
</span><span style="color:#cdd6f4;">
</span><span style="color:#cba6f7;">fn </span><span style="color:#89b4fa;">bar</span><span style="color:#9399b2;">() -&gt; </span><span style="color:#fab387;">Result</span><span style="color:#94e2d5;">&lt;</span><span style="color:#9399b2;">()</span><span style="color:#fab387;">, BarError</span><span style="color:#94e2d5;">&gt; </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    </span><span style="color:#94e2d5;">...
</span><span style="color:#9399b2;">}
</span></code></pre>
<p>In practice, these might be two different dependencies that each define their own <code>Error</code> type. Now, let's say that we have a function <code>foobar()</code> which must call both:</p>
<pre style="background-color:#1e1e2e;"><code class="language-rust"><span style="color:#cba6f7;">fn </span><span style="color:#89b4fa;">foobar</span><span style="color:#9399b2;">() -&gt; </span><span style="color:#fab387;">Result</span><span style="color:#94e2d5;">&lt;</span><span style="color:#9399b2;">()</span><span style="color:#fab387;">, ?</span><span style="color:#94e2d5;">???&gt; </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    </span><span style="color:#89b4fa;">foo</span><span style="color:#9399b2;">()</span><span style="color:#94e2d5;">?</span><span style="color:#9399b2;">;
</span><span style="color:#cdd6f4;">    </span><span style="color:#89b4fa;">bar</span><span style="color:#9399b2;">()</span><span style="color:#94e2d5;">?</span><span style="color:#9399b2;">;
</span><span style="color:#9399b2;">}
</span></code></pre>
<p>We have a problem here. The line <code>foo()?</code> will try to return <code>Err(FooError)</code> if it encounters an error, but <code>bar()?</code> would return <code>Err(BarError)</code> which are not the same type. So what do we put as the error type? A simple solution is to create an enum and use <code>.map_error</code>:</p>
<pre style="background-color:#1e1e2e;"><code class="language-rust"><span style="color:#fab387;">#</span><span style="color:#f9e2af;">[derive(Debug)]
</span><span style="color:#cba6f7;">enum </span><span style="color:#f9e2af;">FoobarError </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    FooError</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">FooError</span><span style="color:#9399b2;">),
</span><span style="color:#cdd6f4;">    BarError</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">BarError</span><span style="color:#9399b2;">)
</span><span style="color:#9399b2;">}
</span><span style="color:#cdd6f4;">
</span><span style="color:#cba6f7;">fn </span><span style="color:#89b4fa;">foobar</span><span style="color:#9399b2;">() -&gt; </span><span style="color:#fab387;">Result</span><span style="color:#94e2d5;">&lt;</span><span style="color:#9399b2;">()</span><span style="color:#fab387;">, FoobarError</span><span style="color:#94e2d5;">&gt; </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    </span><span style="color:#89b4fa;">foo</span><span style="color:#9399b2;">()</span><span style="color:#cdd6f4;">.</span><span style="color:#89b4fa;">map_error</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">FoobarError</span><span style="color:#94e2d5;">::</span><span style="color:#cdd6f4;">FooError</span><span style="color:#9399b2;">)</span><span style="color:#94e2d5;">?</span><span style="color:#9399b2;">;
</span><span style="color:#cdd6f4;">    </span><span style="color:#89b4fa;">bar</span><span style="color:#9399b2;">()</span><span style="color:#cdd6f4;">.</span><span style="color:#89b4fa;">map_error</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">FoobarError</span><span style="color:#94e2d5;">::</span><span style="color:#cdd6f4;">BarError</span><span style="color:#9399b2;">)</span><span style="color:#94e2d5;">?</span><span style="color:#9399b2;">;
</span><span style="color:#9399b2;">}
</span></code></pre>
<p>This works nicely, but now our function becomes a bit verbose. With functions with a lot of <code>Result</code>s, this can get unwieldy very quickly. Luckily, <code>?</code> performs an implicit <code>.into()</code> on the error type, so if we implement <code>From</code> on <code>FoobarError</code> we can remove the <code>.map_error</code>s:</p>
<pre style="background-color:#1e1e2e;"><code class="language-rust"><span style="color:#fab387;">#</span><span style="color:#f9e2af;">[derive(Debug)]
</span><span style="color:#cba6f7;">enum </span><span style="color:#f9e2af;">FoobarError </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    FooError</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">FooError</span><span style="color:#9399b2;">),
</span><span style="color:#cdd6f4;">    BarError</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">BarError</span><span style="color:#9399b2;">)
</span><span style="color:#9399b2;">}
</span><span style="color:#cdd6f4;">
</span><span style="color:#cba6f7;">impl </span><span style="color:#fab387;">From</span><span style="color:#94e2d5;">&lt;</span><span style="color:#fab387;">FooError</span><span style="color:#94e2d5;">&gt; </span><span style="color:#cba6f7;">for </span><span style="color:#f9e2af;">FoobarError </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    </span><span style="color:#cba6f7;">fn </span><span style="color:#89b4fa;">from</span><span style="color:#9399b2;">(</span><span style="color:#eba0ac;">value</span><span style="color:#9399b2;">:</span><span style="color:#eba0ac;"> FooError</span><span style="color:#9399b2;">) -&gt; </span><span style="color:#cba6f7;">Self </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">        </span><span style="color:#cba6f7;">Self</span><span style="color:#94e2d5;">::</span><span style="color:#cdd6f4;">FooError</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">value</span><span style="color:#9399b2;">)
</span><span style="color:#cdd6f4;">    </span><span style="color:#9399b2;">}
</span><span style="color:#9399b2;">}
</span><span style="color:#cdd6f4;">
</span><span style="color:#cba6f7;">impl </span><span style="color:#fab387;">From</span><span style="color:#94e2d5;">&lt;</span><span style="color:#fab387;">BarError</span><span style="color:#94e2d5;">&gt; </span><span style="color:#cba6f7;">for </span><span style="color:#f9e2af;">FoobarError </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    </span><span style="color:#cba6f7;">fn </span><span style="color:#89b4fa;">from</span><span style="color:#9399b2;">(</span><span style="color:#eba0ac;">value</span><span style="color:#9399b2;">:</span><span style="color:#eba0ac;"> BarError</span><span style="color:#9399b2;">) -&gt; </span><span style="color:#cba6f7;">Self </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">        </span><span style="color:#cba6f7;">Self</span><span style="color:#94e2d5;">::</span><span style="color:#cdd6f4;">BarError</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">value</span><span style="color:#9399b2;">)
</span><span style="color:#cdd6f4;">    </span><span style="color:#9399b2;">}
</span><span style="color:#9399b2;">}
</span><span style="color:#cdd6f4;">
</span><span style="color:#cba6f7;">fn </span><span style="color:#89b4fa;">foobar</span><span style="color:#9399b2;">() -&gt; </span><span style="color:#fab387;">Result</span><span style="color:#94e2d5;">&lt;</span><span style="color:#9399b2;">()</span><span style="color:#fab387;">, FoobarError</span><span style="color:#94e2d5;">&gt; </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    </span><span style="color:#89b4fa;">foo</span><span style="color:#9399b2;">()</span><span style="color:#94e2d5;">?</span><span style="color:#9399b2;">;
</span><span style="color:#cdd6f4;">    </span><span style="color:#89b4fa;">bar</span><span style="color:#9399b2;">()</span><span style="color:#94e2d5;">?</span><span style="color:#9399b2;">;
</span><span style="color:#9399b2;">}
</span></code></pre>
<p>This works nicely, but the <code>From&lt;...&gt;</code> impl's are a bit annoying to write. It would be nice to automatically derive them â€” and that's where the crate <a href="https://lib.rs/crates/derive_more"><code>derive_more</code></a> comes in:</p>
<pre style="background-color:#1e1e2e;"><code class="language-rust"><span style="color:#fab387;">#</span><span style="color:#f9e2af;">[derive(Debug, From)]
</span><span style="color:#cba6f7;">enum </span><span style="color:#f9e2af;">FoobarError </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    FooError</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">FooError</span><span style="color:#9399b2;">),
</span><span style="color:#cdd6f4;">    BarError</span><span style="color:#9399b2;">(</span><span style="color:#cdd6f4;">BarError</span><span style="color:#9399b2;">)
</span><span style="color:#9399b2;">}
</span><span style="color:#cdd6f4;">
</span><span style="color:#cba6f7;">fn </span><span style="color:#89b4fa;">foobar</span><span style="color:#9399b2;">() -&gt; </span><span style="color:#fab387;">Result</span><span style="color:#94e2d5;">&lt;</span><span style="color:#9399b2;">()</span><span style="color:#fab387;">, FoobarError</span><span style="color:#94e2d5;">&gt; </span><span style="color:#9399b2;">{
</span><span style="color:#cdd6f4;">    </span><span style="color:#89b4fa;">foo</span><span style="color:#9399b2;">()</span><span style="color:#94e2d5;">?</span><span style="color:#9399b2;">;
</span><span style="color:#cdd6f4;">    </span><span style="color:#89b4fa;">bar</span><span style="color:#9399b2;">()</span><span style="color:#94e2d5;">?</span><span style="color:#9399b2;">;
</span><span style="color:#9399b2;">}
</span></code></pre>
<p>This all works in <code>no_std</code> and did so even before <a href="https://github.com/rust-lang/rust/issues/103765#issuecomment-2155244052"><code>error-in-core</code></a> was stabilized. It's a good idea to also derive the <code>Error</code> trait, which <code>derive_more</code> also supports. You can also derive the <code>Display</code> trait and use <code>thiserror</code>-like syntax, giving you a great amount of flexibility with no boilerplate. I typically define one error enum for the entire crate, mark it pub, define an alias of <code>Result</code> using it, and then use that everywhere.</p>
<h2>Comparison to other approaches</h2>
<p>Usually, when confronted with this problem, application authors reach for crates like <a href="https://lib.rs/crates/anyhow"><code>anyhow</code></a> and library authors for something like <a href="https://lib.rs/crates/thiserror"><code>thiserror</code></a>. <code>derive_more</code> was directly inspired by <code>thiserror</code>; it can do everything that <code>thiserror</code> does plus more. Up until somewhat recently, <code>thiserror</code> didn't support <code>no_std</code>, leading many projects <a href="https://github.com/bevyengine/bevy/issues/15460">like Bevy</a> to switch to <code>derive_more</code>. I'm in the same boat with my projects, having already chosen <code>derive_more</code> due to lack of support on the <code>thiserror</code> side. It is somewhat a matter of personal opinion the choice between the two crates; <code>derive_more</code> having more functionality and being better maintained tips my scales in its favor for me.</p>
<p><code>anyhow</code> is different than <code>thiserror</code> and <code>derive_more</code> as it wraps all errors in one opaque type instead of an enum and is intended to only really show the error message. Since matching on the error type is cumbersome (it can be done through downcasting, though it is not as easy as a simple match statement), it isn't a great choice for libraries. But sometimes I've also wanted to match on an error inside application code, in which case <code>anyhow</code> still isn't a good fit. Compare using <code>anyhow!(...)</code> with adding an extra enum variant: <code>anyhow!</code> is one line, and using an extra enum variant is... three lines, if I'm counting correctly, with the added benefit of having no dependency on any library in the function signature. For this reason I have stopped using <code>anyhow</code> altogether. Anyhow also requires an allocator, making it not suitable for many embedded applications. Having tried a multitude of error handling crates, <code>derive_more</code> has given me the best experience in terms of <code>no_std</code> support and avoidance of boilerplate.<img src="/butterfly.svg" class="butterfly qed"/></p></article><div class="bottom-spacer"></div></main></body></html>